// This file is part of the Archon project, a suite of C++ libraries.
//
// Copyright (C) 2020 Kristian Spangsege <kristian.spangsege@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this
// software and associated documentation files (the "Software"), to deal in the Software
// without restriction, including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef ARCHON_X_CORE_X_RANDOM_HPP
#define ARCHON_X_CORE_X_RANDOM_HPP

/// \file


#include <cstddef>
#include <cstdint>
#include <type_traits>
#include <iterator>
#include <initializer_list>
#include <array>
#include <utility>
#include <memory>
#include <random>
#include <algorithm>
#include <functional>
#include <stdexcept>
#include <vector>

#include <archon/core/features.h>
#include <archon/core/type.hpp>
#include <archon/core/span.hpp>
#include <archon/core/assert.hpp>
#include <archon/core/integer_traits.hpp>
#include <archon/core/integer.hpp>
#include <archon/core/array_seeded_buffer.hpp>


namespace archon::core {


template<class T, class E> auto rand_int(E& engine, T min, T max) -> T;
template<class T, class E> auto rand_int(E& engine) -> T;
template<class T, class E> auto rand_int_max(E& engine, T max) -> T;
template<class T, class E> auto rand_int_mod(E& engine, T module_size) -> T;
template<class T, class E> auto rand_int_bits(E& engine, int num_bits) -> T;
template<class E> bool chance(E& engine, int n, int m);
template<class T, class E> auto rand_float(E& engine, T a, T b) -> T;
template<class T, class E> auto rand_float(E& engine) -> T;
template<class T, class E> void rand_unit_vec(E& engine, core::Span<T> vec);



/// \brief Seed a PRNG nondeterministically.
///
/// This function uses \ref seed_nondeterministically() to perform a nondeterministic
/// seeding of the specified pseudo random number generator.
///
/// Example:
///
/// \code{.cpp}
///
///   std::mt19937_64 random;
///   core::seed_prng_nondeterministically(random);
///   int x = std::uniform_int_distribution<int>(1, 1000)(random);
///
/// \endcode
///
/// \tparam E A pseudo random number generator. Currently, only variations over
/// `std::mersenne_twister_engine` are supported.
///
/// This function is thread-safe.
///
template<class E> void seed_prng_nondeterministically(E& engine);



/// \brief Provide nondeterministic seed sequence for PRNG.
///
/// This function constructs a seed sequence (\ref core::SeedSeq) from nondeterministic
/// input (to the extent possible on this platform) and passes it as argument in an
/// invocation of the specified function. The function is expected to use the passed object
/// for seeding a pseudo random number generator.
///
/// This function makes an effort to provide enough entropy to fully saturate N 32-bit seed
/// values as generated by an invocation of \ref core::SeedSeq::generate(), where N is the
/// value of \p num_seed_words. If that is not possible, this function makes an effort to
/// provide as much entropy as possible.
///
/// The specified function will be invoked as if by the following code:
///
/// \code{.cpp}
///
///   func(seed_seq);
///
/// \endcode
///
/// Here, `seed_seq` is a non-const instance of \ref core::SeedSeq.
///
template<std::size_t num_seed_words, class F> inline void seed_nondeterministically(F func);



/// \brief Provide nondeterministic seed sequence for PRNG.
///
/// This function is equivalent to \ref seed_nondeterministically(), but allows for the
/// number of seed words to not be known at compile time. The cost is one dynamic
/// allocation.
///
template<class F> inline void seed_nondeterministically_a(std::size_t num_seed_words, F func);



/// \brief Provide good quality seeding for random number generators.
///
/// This class offers a way to produce a reasonably well-behaved sequence of 32-bit integers
/// from a potentially poorly distributed or strongly biased initial seed sequence. The
/// produced sequence (\ref generate()) will be rectangularly distributed over the entire
/// 32-bit range. For optimum results, the initial seed sequence should contain enough
/// entropy to saturate all the generated integers. For example, if N integers are
/// generated, the initial seed sequence should contain at least N times 32 bits of entropy.
///
/// This class provides the same functionality as `std::seed_seq`, but adds the ability to
/// refer to an externally owned initial seed sequence (\ref no_copy()). Use this to avoid
/// dynamic allocation.
///
/// Just like `std::seed_seq`, this class meets the *seed sequence* requirements as defined
/// by C++17 section 29.6.1.2.
///
/// The \ref generate() function is implemented using exactly the same algorithm as is
/// required for `std::seed_seq::generate()`.
///
class SeedSeq {
public:
    using result_type = std::uint_least32_t;
    using span_type = core::Span<const result_type>;

    /// \{
    ///
    /// \brief Avoid copying the initial seed sequence.
    ///
    /// In contrast to a seed sequence object created by one of the (standard) constructors
    /// of this class, a seed sequence object produced by this function does not contain a
    /// copy of the initial seed sequence. It instead contains a copy of the specified
    /// memory reference, so the caller must ensure that the referenced memory stays alive
    /// for as long as the produced seed sequence object is in use. The upside is that no
    /// dynamic memory allocation is needed.
    ///
    /// `no_copy_a()` allows you to source the initial seed sequence from multiple places.
    ///
    static auto no_copy(span_type seq) noexcept -> SeedSeq;
    static auto no_copy_a(core::Span<const span_type> seq_seq) -> SeedSeq;
    /// \}

    SeedSeq() noexcept = default;
    template<class T> SeedSeq(std::initializer_list<T> seq);
    template<class I> SeedSeq(I begin, I end);

    template<class I> void generate(I begin, I end) const;

    auto size() const noexcept -> std::size_t;
    template<class I> void param(I dest) const;

    /// \{
    ///
    /// \brief Movability.
    ///
    /// Seed sequences are movable.
    ///
    SeedSeq(SeedSeq&&) noexcept;
    auto operator=(SeedSeq&&) noexcept -> SeedSeq&;
    /// \}

private:
    std::unique_ptr<result_type[]> m_seq_owner;
    span_type m_seq;
    core::Span<const span_type> m_seq_seq;

    void init(SeedSeq&&) noexcept;
    template<class I> void init(I begin, I end);
};








// Implementation


template<class T, class E> inline auto rand_int(E& engine, T min, T max) -> T
{
    static_assert(core::is_integer<T>());
    using traits_type = core::IntegerTraits<T>;
    // Using promoted type in order to allow `bool` and character types to be handled by the
    // simple method below even though they are not directly supported by
    // `std::uniform_int_distribution`.
    using type = core::promoted_type<T>;
    constexpr bool is_simple = core::type_in<type, short, unsigned short, int, unsigned, long,
                                             unsigned long, long long, unsigned long long>;
    if constexpr (is_simple) {
        type val = std::uniform_int_distribution<type>(min, max)(engine); // Throws
        return core::int_cast_a<T>(val);
    }
    else {
        using part_type = typename traits_type::part_type;
        constexpr int part_width = core::int_width<part_type>();
        constexpr int num_parts = traits_type::num_parts;
        using parts_type = std::array<part_type, num_parts>;
        auto add = [&](parts_type a, parts_type b) noexcept {
            parts_type c;
            bool carry = false;
            for (int i = 0; i < num_parts; ++i) {
                part_type part_1 = a[i];
                part_type part_2 = part_1 + b[i];
                part_type part_3 = part_2 + int(carry);
                c[i] = part_3;
                carry = (part_2 < part_1 || part_3 < part_2);
            }
            return c;
        };
        auto sub = [&](parts_type a, parts_type b) noexcept {
            parts_type c;
            bool carry = false;
            for (int i = 0; i < num_parts; ++i) {
                part_type part_1 = a[i];
                part_type part_2 = part_1 - b[i];
                part_type part_3 = part_2 - int(carry);
                c[i] = part_3;
                carry = (part_2 > part_1 || part_3 > part_2);
            }
            return c;
        };
        auto find_msb_pos = [&](parts_type a) noexcept {
            for (int i = 0; i < num_parts; ++i) {
                int j = (num_parts - 1) - i;
                part_type part = a[j];
                if (ARCHON_LIKELY(part != 0))
                    return j * part_width + core::int_find_msb_pos(part);
            }
            return -1;
        };
        auto less = [&](parts_type a, parts_type b) noexcept {
            for (int i = 0; i < num_parts; ++i) {
                int j = (num_parts - 1) - i;
                if (ARCHON_LIKELY(a[j] == b[j]))
                    continue;
                return (a[j] < b[j]);
            }
            return false;
        };
        parts_type min_2 = traits_type::get_parts(min);
        parts_type max_2 = traits_type::get_parts(max);
        parts_type diff = sub(max_2, min_2);
        int num_bits = 1 + find_msb_pos(diff);
        int num_full_parts = num_bits / part_width;
        int num_extra_bits = num_bits % part_width;
        parts_type parts = {};
        for (;;) {
            for (int i = 0; i < num_full_parts; ++i)
                parts[i] = core::rand_int<part_type>(engine); // Throws
            if (num_extra_bits > 0) {
                parts[num_full_parts] = core::rand_int_bits<part_type>(engine, num_extra_bits); // Throws
            }
            if (ARCHON_LIKELY(!less(diff, parts)))
                break;
        }
        return traits_type::from_parts(add(min_2, parts));
    }
}


template<class T, class E> inline auto rand_int(E& engine) -> T
{
    return core::rand_int(engine, core::int_min<T>(), core::int_max<T>()); // Throws
}


template<class T, class E> inline auto rand_int_max(E& engine, T max) -> T
{
    return core::rand_int<T>(engine, 0, max); // Throws
}


template<class T, class E> inline auto rand_int_mod(E& engine, T module_size) -> T
{
    return core::rand_int_max(engine, T(module_size - 1)); // Throws
}


template<class T, class E> inline auto rand_int_bits(E& engine, int num_bits) -> T
{
    ARCHON_ASSERT(num_bits <= core::num_value_bits<T>());
    T max = core::int_mask<T>(num_bits);
    return core::rand_int_max(engine, max); // Throws
}


template<class E> inline bool chance(E& engine, int n, int m)
{
    return (core::rand_int_mod(engine, m) < n); // Throws
}


template<class T, class E> inline auto rand_float(E& engine, T a, T b) -> T
{
    return std::uniform_real_distribution<T>(a, b)(engine); // Throws
}


template<class T, class E> inline auto rand_float(E& engine) -> T
{
    return core::rand_float<T>(engine, 0, 1); // Throws
}


namespace impl {


// Variant: Optimized for low dimensionality
template<class T, class E> void rand_unit_vec_1(E& engine, core::Span<T> vec)
{
    for (;;) {
        T sq_sum = 0;
        for (T& x : vec) {
            x = 2 * core::rand_float<T>(engine) - 1; // Throws
            sq_sum += x * x;
        }
        if (ARCHON_LIKELY(sq_sum >= 0.001 && sq_sum < 1)) {
            T f = T(1) / std::sqrt(sq_sum);
            for (T& x : vec)
                x *= f;
            return;
        }
    }
}


// Variant: Optimized for high dimensionality
template<class T, class E> void rand_unit_vec_2(E& engine, core::Span<T> vec)
{
    std::normal_distribution<T> distr;
    for (;;) {
        T sq_sum = 0;
        for (T& x : vec) {
            x = distr(engine); // Throws
            sq_sum += x * x;
        }
        if (ARCHON_LIKELY(sq_sum >= 0.001)) {
            T f = T(1) / std::sqrt(sq_sum);
            for (T& x : vec)
                x *= f;
            return;
        }
    }
}


} // namespace impl


template<class T, class E> inline void rand_unit_vec(E& engine, core::Span<T> vec)
{
    static_assert(std::is_floating_point_v<T>);
    if (ARCHON_LIKELY(vec.size() <= 3)) {
        impl::rand_unit_vec_1(engine, vec);
    }
    else {
        impl::rand_unit_vec_2(engine, vec);
    }
}


namespace impl {


struct NondeterministicRandomSeeder {
    static constexpr std::size_t num_extra_entropy_words = 3;

    using input_word_type = std::random_device::result_type;
    using buffer_ref_type = core::Span<input_word_type>;
    using extra_entropy_type = std::array<input_word_type, num_extra_entropy_words>;

    template<class T, std::size_t w, std::size_t n, std::size_t m, std::size_t r, T a,
             std::size_t u, T d, std::size_t s, T b, std::size_t t, T c, std::size_t l, T f>
    static void seed_prng(std::mersenne_twister_engine<T, w, n, m, r, a, u, d, s, b, t, c, l, f>& engine)
    {
        constexpr std::size_t num_state_words = n;
        constexpr std::size_t state_word_size = w;
        constexpr std::size_t num_seed_words = get_num_seed_words(num_state_words, state_word_size); // Throws
        core::seed_nondeterministically<num_seed_words>([&](core::SeedSeq& seed_seq) {
            engine.seed(seed_seq); // Throws
        }); // Throws
    }

    static constexpr auto get_num_seed_words(std::size_t num_state_words, std::size_t state_word_size) -> std::size_t
    {
        std::size_t n = num_state_words;
        core::int_mul(n, state_word_size); // Throws
        std::size_t bits_per_seed_word = 32;
        core::int_add(n, bits_per_seed_word - 1); // Throws
        n /= bits_per_seed_word;
        return n;
    }

    static constexpr auto get_num_input_words(std::size_t num_seed_words) -> std::size_t
    {
        // Ideally, we could have used `std::random_device::entropy()` as the actual number
        // of bits of entropy produced per invocation of `std::random_device::operator()`,
        // however, it is incorrectly implemented on many platform. Also, it is supposed to
        // return zero when `std::random_device` is just a PRNG, but that would leave us
        // with no way to continue.
        //
        // When the actual entropy from `std::random_device` is less than maximum, the
        // seeding will be less than optimal. For example, if the actual entropy is only
        // half of the maximum, then the seeding will only produce half the entropy that it
        // ought to, but that will generally still be a good seeding.
        //
        // For the (assumed) rare cases where `std::random_device` is a PRGN that is not
        // nondeterministically seeded, we include a bit of extra entropy taken from such
        // places as the current time and the ID of the executing process (when available).
        //
        std::size_t n = num_seed_words;
        core::int_mul(n, 32); // Throws
        std::size_t bits_per_input_word = core::int_width<input_word_type>();
        core::int_add(n, bits_per_input_word - 1); // Throws
        n /= bits_per_input_word;
        core::int_add(n, num_extra_entropy_words); // Throws
        return n;
    }

    template<class F> static void seed(buffer_ref_type buffer, F func)
    {
        std::random_device rnddev; // Throws
        std::generate(buffer.begin(), buffer.end() - num_extra_entropy_words, std::ref(rnddev)); // Throws
        extra_entropy_type extra_entropy;
        get_extra_entropy(extra_entropy); // Throws
        std::copy(extra_entropy.begin(), extra_entropy.end(), buffer.end() - num_extra_entropy_words);
        auto seed_seq = core::SeedSeq::no_copy(buffer);
        func(seed_seq); // Throws
    }

    static void get_extra_entropy(extra_entropy_type&);
};


} // namespace impl



template<class E> inline void seed_prng_nondeterministically(E& engine)
{
    using Seeder = impl::NondeterministicRandomSeeder;
    Seeder::seed_prng(engine); // Throws
}


template<std::size_t num_seed_words, class F> inline void seed_nondeterministically(F func)
{
    using Seeder = impl::NondeterministicRandomSeeder;
    constexpr std::size_t size = Seeder::get_num_input_words(num_seed_words); // Throws
    std::array<Seeder::input_word_type, size> buffer;
    Seeder::seed(buffer, std::move(func)); // Throws
}


template<class F> inline void seed_nondeterministically_a(std::size_t num_seed_words, F func)
{
    using Seeder = impl::NondeterministicRandomSeeder;
    // Enough seed memory for Mersenne-Twister engine
    constexpr std::size_t seed_memory_size = Seeder::get_num_input_words(624);
    std::size_t size = Seeder::get_num_input_words(num_seed_words); // Throws
    core::ArraySeededBuffer<Seeder::input_word_type, seed_memory_size> buffer(size); // Throws
    Seeder::seed(buffer, std::move(func)); // Throws
}



// ============================ SeedSeq ============================


inline auto SeedSeq::no_copy(span_type seq) noexcept -> SeedSeq
{
    SeedSeq seq_2;
    seq_2.m_seq = seq;
    seq_2.m_seq_seq = { &seq_2.m_seq, 1 };
    return seq_2;
}


template<class T> inline SeedSeq::SeedSeq(std::initializer_list<T> seq)
    : SeedSeq(seq.begin(), seq.end()) // Throws
{
}


template<class I> inline SeedSeq::SeedSeq(I begin, I end)
{
    constexpr bool is_forward_iter =
        std::is_convertible_v<typename std::iterator_traits<I>::iterator_category, std::forward_iterator_tag>;
    if constexpr (is_forward_iter) {
        init(begin, end); // Throws
    }
    else {
        std::vector<result_type> vec(begin, end); // Throws
        init(vec.begin(), vec.end()); // Throws
    }
}


template<class I> void SeedSeq::generate(I begin, I end) const
{
    // The algorithm below conincides with the one required by C++17 for
    // `std::seed_seq::generate()`.

    static_assert(std::is_convertible_v<typename std::iterator_traits<I>::iterator_category,
                  std::random_access_iterator_tag>);

    using T = typename std::iterator_traits<I>::value_type;
    static_assert(std::is_unsigned_v<T>);
    static_assert(core::int_width<T>() >= 32);

    if (begin == end)
        return;

    std::fill(begin, end, T(0x8B8B8B8Bu));

    std::size_t n = std::size_t(end - begin);
    std::size_t t = (n >= 623 ? 11 :
                     (n >=  68 ? 7 :
                      (n >=  39 ? 5 :
                       (n >=   7 ? 3 :
                        std::size_t((n - 1) / 2)))));
    std::size_t p = std::size_t((n - t) / 2);
    std::size_t q = std::size_t(p + t);

    auto mod = [](auto val) noexcept {
        return val & core::int_mask<std::uint_least32_t>(32);
    };

    std::size_t m = 0;
    auto integrate = [&](std::size_t s, auto calc) {
        for (std::size_t i = 0; i < s; ++i) {
            std::size_t k = m + i;
            auto arg = begin[k % n] ^ begin[(k + p) % n] ^ begin[(k - 1) % n];
            auto r_1 = 1664525u * (arg ^ (mod(arg) >> 27));
            auto r_2 = calc(r_1, k, i);
            begin[(k + p) % n] = T(mod(begin[(k + p) % n] + r_1));
            begin[(k + q) % n] = T(mod(begin[(k + q) % n] + r_2));
            begin[k % n] = T(mod(r_2));
        }
        core::int_add(m, s); // Throws
    };

    std::size_t u = size();
    integrate(1, [&](auto r, std::size_t, std::size_t) {
        return r + u;
    });

    for (auto seq : m_seq_seq) {
        integrate(seq.size(), [&](auto r, std::size_t k, std::size_t i) {
            return r + k % n + seq[i];
        });
    }

    if (n > m) {
        integrate(n - m, [&](auto r, std::size_t k, std::size_t) {
            return r + k % n;
        });
    }

    for (std::size_t k = m; k < m + n; ++k) {
        auto arg = begin[k % n] + begin[(k + p) % n] + begin[(k - 1) % n];
        auto r_1 = 1566083941u * (arg ^ (mod(arg) >> 27));
        auto r_2 = r_1 - k % n;
        begin[(k + p) % n] = T(mod(begin[(k + p) % n] ^ r_1));
        begin[(k + q) % n] = T(mod(begin[(k + q) % n] ^ r_2));
        begin[k % n] = T(mod(r_2));
    }
}


template<class I> void SeedSeq::param(I dest) const
{
    I dest_2 = dest;
    for (auto seq : m_seq_seq)
        dest_2 = std::copy_n(seq.data(), seq.size(), dest_2); // Throws
}


inline SeedSeq::SeedSeq(SeedSeq&& other) noexcept
    : SeedSeq()
{
    init(std::move(other));
}


inline auto SeedSeq::operator=(SeedSeq&& other) noexcept -> SeedSeq&
{
    init(std::move(other));
    return *this;
}


inline void SeedSeq::init(SeedSeq&& other) noexcept
{
    if (other.m_seq_seq.data() == &other.m_seq) {
        ARCHON_ASSERT(other.m_seq_seq.size() == 1);
        m_seq_owner = std::move(other.m_seq_owner);
        m_seq = other.m_seq;
        m_seq_seq = { &m_seq, 1 };
        other.m_seq = {};
        other.m_seq_seq = {};
    }
    else {
        ARCHON_ASSERT(!other.m_seq_owner);
        ARCHON_ASSERT(other.m_seq.size() == 0);
        m_seq_seq = other.m_seq_seq;
        other.m_seq_seq = {};
    }
}


template<class I> void SeedSeq::init(I begin, I end)
{
    static_assert(std::is_convertible_v<typename std::iterator_traits<I>::iterator_category,
                  std::forward_iterator_tag>);
    auto n_1 = std::distance(begin, end); // Throws
    if (ARCHON_LIKELY(n_1 > 0)) {
        std::size_t n_2 = 0;
        if (ARCHON_LIKELY(core::try_int_cast(n_1, n_2))) {
            m_seq_owner = std::make_unique<result_type[]>(n_2); // Throws
            std::copy(begin, end, m_seq_owner.get());
            m_seq = { m_seq_owner.get(), n_2 };
            m_seq_seq = { &m_seq, 1 };
            return;
        }
        throw std::length_error("Initial seed sequence");
    }
}


} // namespace archon::core

#endif // ARCHON_X_CORE_X_RANDOM_HPP
